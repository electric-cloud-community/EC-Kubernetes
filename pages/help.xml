<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta content="text/html; charset=us-ascii" http-equiv="content-type"/>
    <title>@PLUGIN_KEY@ Plugin</title>
    <link rel="stylesheet" href="../../plugins/@PLUGIN_NAME@/pluginhelp.css" type="text/css" media="screen"/>
</head>
<body>
<!--
    Generated by PluginWizardHelp
    https://github.com/electric-cloud/PluginWizardHelp
    Do *NOT* edit manually, use help file generation.
-->
<div class="help">
    <h1>@PLUGIN_KEY@</h1>
    <p>Plugin version @PLUGIN_VERSION@</p>
    
    <p>Revised on April 17, 2020</p>
    
    <hr style="margin-left: -10px; margin-top: 10px; height: 1px; width: 100%; color: #5981BD;" noshade="noshade"/>
    <h1>Contents</h1>
    <ul>
    
    <li><a href="#overview">Overview</a></li>
    
    
    
    
    
    
    
    
    <li><a href="#CreateConfiguration">Plugin Configuration</a></li>
    

    
    <li><a href="#procedures">Plugin Procedures</a></li>
    

    <ul>
        

        <li><a href="#CheckCluster">Check Cluster</a></li>
        

        <li><a href="#DeployService">Deploy Service</a></li>
        

        <li><a href="#UndeployService">Undeploy Service</a></li>
        

        <li><a href="#Discover">Discover</a></li>
        

        <li><a href="#InvokeKubernetesAPI">Invoke Kubernetes API</a></li>
        

        <li><a href="#WaitForKubernetesAPI">Wait For Kubernetes API</a></li>
        

        <li><a href="#CreateResource">Create Resource (DEPRECATED)</a></li>
        

        <li><a href="#ImportMicroservices">Import Microservices</a></li>
        
    </ul>

    

    
    
    
    <li><a href="#usecases">Use Cases</a></li>
    <ul>
        
        <li><a href="#RollingUpdates">Rolling Updates</a></li>
        
        <li><a href="#CanaryDeployments">Canary Deployments</a></li>
        
        <li><a href="#BlueGreenDeployments">Blue/Green Deployments</a></li>
        
    </ul>
    
    
    
    
    <li><a href="#knownIssues">Known Issues</a></li>
    
    
    <li><a href="#releaseNotes">Release Notes</a></li>
</ul>

    
    <h1>Overview</h1>
    <p><p>EC-Kubernetes plugin integrates with the kubernetes cluster to run Docker containers. Kubernetes schedules your containers into the cluster and manages them automatically based on requirements you define (such as CPU and memory).</p>
<p>You need to have a Kubernetes cluster available for using this plugin.</p>
</p>
    
    
    
    
    
    

    <!--TODO custom blocks-->

    
    <div id="CreateConfiguration">
        <a name='CreateConfiguration' id="CreateConfiguration"> </a>
        <h1>Plugin Configurations</h1>

        <p>
            Plugin configurations are sets of parameters that apply
            across some or all of the plugin procedures. They
            reduce repetition of common values, create
            predefined parameter sets for end users, and
            securely store credentials where needed. Each configuration
            is given a unique name that is entered in designated
            parameters on procedures that use them.<br /><br />
        </p>

        <h3>Creating Plugin Configurations</h3>
        <p>To create plugin configurations in CloudBees Flow,
            do these steps:</p>

        <li>Go to <b>Administration</b> &gt; <b>Plugins</b> to open the Plugin Manager.</li>
        <li>Find the @PLUGIN_NAME@ row.</li>
        <li>Click <b>Configure</b> to open the
             Configurations page.</li>
        <li>Click <b>Create Configuration</b> as per the description of parameters below.</li>
        
        <p>For communicating with the Kubernetes cluster, you need the following details:</p>
<ol>
<li>
<p>Base address of API Endpoint URL</p>
</li>
<li>
<p>Bearer token which has authorization to access API.</p>
<p>Use the following steps for creating a service account and obtaining the service account bearer token:</p>
<ul>
<li>
<p>Download the Kubeconfig file from your Kubernetes cluster. Or if you have direct access to Kubectl shell of the cluster, that will work too.</p>
</li>
<li>
<p>You will need to install Kubectl (
<a href="http://kubernetes.io/docs/user-guide/prereqs/" target="_blank">http://kubernetes.io/docs/user-guide/prereqs/</a>
) or have access to Kubectl shell</p>
</li>
<li>
<p>Create a service account with following kubectl command:</p>
<p>kubectl create serviceaccount api-user</p>
</li>
<li>
<p>Assign cluster-admin role to serviceaccount api-user. Specify serviceaccount name as default:api-user, if it is created in default namespace.</p>
<p>kubectl create clusterrolebinding root-cluster-admin-binding --clusterrole=cluster-admin --serviceaccount=default:api-user</p>
</li>
<li>
<p>Get details of the service account we just created, from the output determine name of secret in which data is stored:</p>
<p>kubectl get serviceaccount api-user -o yaml</p>
</li>
<li>
<p>Assuming name of secret from above step is secret-1234, get details of secret:</p>
<p>kubectl get secret secret-1234 -o yaml</p>
</li>
<li>
<p>The value of the token field in the output above is base64 encoded. We need to decode it to use in the plugin configuration. On a Unix like system, following command can be used to decode the value:</p>
<p>echo &quot;&lt;encoded_token_value&gt;&quot; | base64 --decode</p>
</li>
</ul>
</li>
</ol>

        
        Configuration Parameters
        <table class="grid">
            <thead>
            <tr>
                <th>Parameter</th>
                <th>Description</th>
            </tr>
            </thead>
            <tbody>
            
            <tr>
                
                    <td class="required">Configuration</td>
                    <td>Unique name for the plugin configuration.</td>
                
            </tr>
            
            <tr>
                
                    <td >Description</td>
                    <td>Description for the plugin configuration.</td>
                
            </tr>
            
            <tr>
                
                    <td class="required">Kubernetes API Endpoint</td>
                    <td>The endpoint at which Kubernetes API will be reachable. Must be a IP address or a resolvable DNS name.</td>
                
            </tr>
            
            <tr>
                
                    <td class="required">Bearer Token of Kubernetes Cluster</td>
                    <td>Service account bearer token for a service account which has permissions to create resources in the Kubernetes cluster.</td>
                
            </tr>
            
            <tr>
                
                    <td >Kubernetes Version</td>
                    <td>Kubernetes version running on the cluster master</td>
                
            </tr>
            
            <tr>
                
                    <td >Test Connection</td>
                    <td>Check this checkbox to verify connectivity to Kubernetes master.</td>
                
            </tr>
            
            <tr>
                
                    <td >URI Path for Checking Cluster Connectivity</td>
                    <td>URI path to use with the Kubernetes API endpoint for checking cluster connectivity, e.g., 'api/v1/apis'</td>
                
            </tr>
            
            <tr>
                
                    <td >Log Level</td>
                    <td>Log level to use for logging output. Error=4, Warning=3, Info=2, Debug=1.</td>
                
            </tr>
            
            </tbody>
        </table>
        
    </div>
    

    

    <h1 id="procedures">Plugin Procedures</h1>
    
    

    
    <div id="CheckCluster">
        <h2>Check Cluster</h2>
        
        
        <p>Checks that a Kubernetes cluster exists and is reachable. All other entities such as  Pods, services, and replication controllers all run on top of a cluster.</p>
        
        
        <h3>Check Cluster Parameters</h3>
        <table class="grid">
            <thead>
            <tr>
                <th>Parameter</th>
                <th>Description</th>
            </tr>
            </thead>
            <tbody>
            
            <tr>
                
                <td class="required">Configuration</td>
                <td>The name of an existing configuration which holds all the connection information for the Kubernetes cluster.</td>
                
            </tr>
            
            </tbody>
        </table>

        

        
    </div>

    
    <div id="DeployService">
        <h2>Deploy Service</h2>
        
        
        <p>Creates or updates the Kubernetes service and the Deployment configuration for Pods and ReplicaSets in the Kubernetes cluster.</p>
        
        
        <h3>Deploy Service Parameters</h3>
        <table class="grid">
            <thead>
            <tr>
                <th>Parameter</th>
                <th>Description</th>
            </tr>
            </thead>
            <tbody>
            
            <tr>
                
                <td class="required">Service Name</td>
                <td>The name of the service in CloudBees Flow that encapsulates the service to be deployed on the Kubernetes cluster. Please note that this name will be modified to comply with the naming conventions of Kubernetes.</td>
                
            </tr>
            
            <tr>
                
                <td >Service Revision ID</td>
                <td>Revision Id of the service in CloudBees Flow.</td>
                
            </tr>
            
            <tr>
                
                <td class="required">Project Name</td>
                <td>The name of the project that the service belongs to. In case of an application-level service it also owns the application.</td>
                
            </tr>
            
            <tr>
                
                <td >Application Name</td>
                <td>The name of the application that the service belongs to. Not applicable for a top-level service.</td>
                
            </tr>
            
            <tr>
                
                <td >Application Revision ID</td>
                <td>Revision Id of the application version that the service belongs to.</td>
                
            </tr>
            
            <tr>
                
                <td class="required">Cluster Name</td>
                <td>The name of the cluster in CloudBees Flow that encapsulates the Kubernetes cluster on which the service is to be deployed.</td>
                
            </tr>
            
            <tr>
                
                <td >Cluster Or Environment Project Name</td>
                <td>The name of the project that the cluster belongs to if it is a top-level project cluster. Or the name of the project that the environment belongs to if it is an environment-scoped cluster.</td>
                
            </tr>
            
            <tr>
                
                <td >Environment Name</td>
                <td>The name of the environment that the cluster belongs to. Not applicable for a top-level project cluster.</td>
                
            </tr>
            
            <tr>
                
                <td >Results Property Sheet</td>
                <td>Name of the property sheet where the output properties for the deployed service will be saved. If not specified, will default to '/myParent/parent'.</td>
                
            </tr>
            
            </tbody>
        </table>

        

        
    </div>

    
    <div id="UndeployService">
        <h2>Undeploy Service</h2>
        
        
        <p>Undeploys a previously deployed service on the Kubernetes cluster</p>
        
        
        <h3>Undeploy Service Parameters</h3>
        <table class="grid">
            <thead>
            <tr>
                <th>Parameter</th>
                <th>Description</th>
            </tr>
            </thead>
            <tbody>
            
            <tr>
                
                <td class="required">Service Name</td>
                <td>The name of the service in CloudBees Flow that encapsulates the service that was previously deployed on the Kubernetes cluster.</td>
                
            </tr>
            
            <tr>
                
                <td >Service Revision ID</td>
                <td>Revision Id of the service in CloudBees Flow.</td>
                
            </tr>
            
            <tr>
                
                <td class="required">Project Name</td>
                <td>The name of the project that the service belongs to. In case of an application-level service it also owns the application.</td>
                
            </tr>
            
            <tr>
                
                <td >Application Name</td>
                <td>The name of the application that the service belongs to. Not applicable for a top-level service.</td>
                
            </tr>
            
            <tr>
                
                <td >Application Revision ID</td>
                <td>Revision Id of the application version that the service belongs to.</td>
                
            </tr>
            
            <tr>
                
                <td class="required">Environment Name</td>
                <td>The name of the environment that the cluster belongs to.</td>
                
            </tr>
            
            <tr>
                
                <td >Environment Project Name</td>
                <td>The name of the project that the environment belongs to. If not specified, the environment is assumed to be in the same project as the service.</td>
                
            </tr>
            
            <tr>
                
                <td >Cluster Name</td>
                <td>The name of the cluster in the environment on which the service was previously deployed. If not specified, the application tier mapping will be used to find the cluster name.</td>
                
            </tr>
            
            </tbody>
        </table>

        

        
    </div>

    
    <div id="Discover">
        <h2>Discover</h2>
        
        
        Automatically create microservice models in CloudBees Flow for the services and the pods discovered within a namespace on a Kubernetes cluster.
<div>
    <ol>
        <li><b>Select your method of discovery from a Kubernetes Cluster</b>  There are two options for connecting to Kubernetes for discovery
            <ul>
                <li><b>Existing CloudBees Flow Environment and Cluster</b>  Use the Cluster configuration details in an existing CloudBees Flow environment to connect to Kubernetes. Enter details for the existing environment and cluster in the following parameters:
                    <ul>
                        <li>Environment Project Name: The project containing the existing environment</li>
                        <li>Environment Name:  the name of an existing environment that contains the Kubernetes backend cluster to be discovered</li>
                        <li>Cluster Name: The name of the CloudBees Flow cluster in the environment above that represents the Kubernetes cluster</li>
                    </ul></li>
                <li><b>Kubernetes Connection Details</b>  Enter Kubernetes endpoint and Account details to directly connect to the endpoint and discover the clusters and pods.  Enter the endpoint and account details in the following parameters:
                    <ul>
                        <li>Kubernetes Endpoint: The endpoint where the Kubernetes endpoint will be reachable</li>
                        <li>Service Account API Token</li>
                        <li><i>If selecting this connection option, you can optionally enter a new values for Environment Name and Cluster Name parameters, to create a new environment and cluster in CloudBees Flow based on the discovered services and pods.</i></li>
                    </ul>
                </li>
            </ul></li>
        <li><b>Determine how the discovered microservices will be created in CloudBees Flow</b>
            <ul>
                <li><b>Create the microservices individually at the top-level within the project.</b> All discovered microservices will be created at the top-level.  Enter the following parameters:
                    <ul>
                        <li>Project Name: Enter the name of the project where the microservices will be created</li>
                    </ul>
                </li>
                <li><b>Create the Microservices within an application in CloudBees Flow.</b> All discovered microservices will be created as services within a new application. Enter the following parameters:
                    <ul>
                        <li>Project Name: Enter the name of the project where the new application will be created</li>
                        <li>Create Microservices within and Application:  Select the checkbox</li>
                        <li>Application Name:  The name of a new application which will be created in CloudBees Flow containing the discovered services</li>
                    </ul>
                </li></ul>
        </li>
    </ol>
</div>

        
        
            <p>Procedure looks for services and deployments on Kubernetes
cluster and transfers data into CloudBees Flow. Services found
in cluster will be mapped to Services objects in CloudBees Flow,
then associated deployments will be found and containers
definitions retrieved from there.</p>
<p>If the object with the provided name already exists in the CloudBees Flow, this object will be skipped and a warning message will be emitted to logs.</p>

        
        <h3>Discover Parameters</h3>
        <table class="grid">
            <thead>
            <tr>
                <th>Parameter</th>
                <th>Description</th>
            </tr>
            </thead>
            <tbody>
            
            <tr>
                
                <td class="required">Environment Project Name</td>
                <td>The project containing the existing environment, or where the new environment will be created.</td>
                
            </tr>
            
            <tr>
                
                <td class="required">Environment Name</td>
                <td>Provide the name of an existing environment that contains the Kubernetes-backend cluster to be discovered. If the environment does not already exist, provide the Kubernetes connection details below for discovery, and a new environment will be created.</td>
                
            </tr>
            
            <tr>
                
                <td class="required">Cluster Name</td>
                <td>In an existing environment, provide the name of the CloudBees Flow cluster representing the Kubernetes cluster whose deployed services are to be discovered. If the environment does not already exist, provide the name of the cluster to be created in the new environment.</td>
                
            </tr>
            
            <tr>
                
                <td >Kubernetes API Endpoint</td>
                <td>The endpoint at which the Kubernetes API will be reachable. Must be an IP address or a resolvable DNS name. This field is required and used only if you are not providing an existing environment above for discovery.</td>
                
            </tr>
            
            <tr>
                
                <td >Service Account API Token</td>
                <td>Service account bearer token for a service account which has permissions to create resources in the Kubernetes cluster. This field is required and used only if you are not providing an existing environment above for discovery.</td>
                
            </tr>
            
            <tr>
                
                <td class="required">Kubernetes Namespace</td>
                <td>The name of the Kubernetes namespace within which the deployed services should be discovered. Default to 'default' namespace.</td>
                
            </tr>
            
            <tr>
                
                <td class="required">Project Name</td>
                <td>The name of project in which the discovered microservices will be created.</td>
                
            </tr>
            
            <tr>
                
                <td >Create Microservices within an Application</td>
                <td>(Optional) Select to create all discovered services in the Kubernetes namespace within one application in CloudBees Flow. If selected, then the application name must be provided. If unselected, microservices will be created at the top-level in the project.</td>
                
            </tr>
            
            <tr>
                
                <td >Application Name</td>
                <td>The name of the new application that will contain the microservices. Required only if 'Create Microservices within an Application' is selected.</td>
                
            </tr>
            
            </tbody>
        </table>

        

        
    </div>

    
    <div id="InvokeKubernetesAPI">
        <h2>Invoke Kubernetes API</h2>
        
        
        <p>Invokes Kubernetes REST API based on specified input parameters. Can also be used to create or modify a resource in Kubernetes cluster based on JSON/YAML as input</p>
        
        
        <h3>Invoke Kubernetes API Parameters</h3>
        <table class="grid">
            <thead>
            <tr>
                <th>Parameter</th>
                <th>Description</th>
            </tr>
            </thead>
            <tbody>
            
            <tr>
                
                <td class="required">Configuration</td>
                <td>The name of an existing configuration which holds all the connection information for the Kubernetes cluster.</td>
                
            </tr>
            
            <tr>
                
                <td class="required">Kubernetes API URI</td>
                <td>The URI for the Kubernetes API to invoke. E.g., '/api/v1/namespaces'.</td>
                
            </tr>
            
            <tr>
                
                <td class="required">HTTP method for the Kubernetes API</td>
                <td>HTTP method for the Kubernetes REST API to be invoked.</td>
                
            </tr>
            
            <tr>
                
                <td >Request Payload Format</td>
                <td>Format of the request payload. Possible values are 'json' or 'yaml'. Not applicable for HTTP methods 'get' and 'delete'.</td>
                
            </tr>
            
            <tr>
                
                <td >Request Payload</td>
                <td>The request body/payload in JSON or YAML format. Not applicable for HTTP methods 'get' and 'delete'.</td>
                
            </tr>
            
            <tr>
                
                <td >Output Property Location</td>
                <td>Location of the output property where the API response will be saved. If not specified, then if the procedure is invoked in a pipeline, the location will default to '/myStageRuntime/k8sAPIResult' else it will default to '/myJob/k8sAPIResult'.</td>
                
            </tr>
            
            </tbody>
        </table>

        

        
    </div>

    
    <div id="WaitForKubernetesAPI">
        <h2>Wait For Kubernetes API</h2>
        
        
        <p>Polls on Kubernetes REST API to check specific field of API response.</p>
        
        
        <h3>Wait For Kubernetes API Parameters</h3>
        <table class="grid">
            <thead>
            <tr>
                <th>Parameter</th>
                <th>Description</th>
            </tr>
            </thead>
            <tbody>
            
            <tr>
                
                <td class="required">Configuration</td>
                <td>The name of an existing configuration which holds all the connection information for the Kubernetes cluster.</td>
                
            </tr>
            
            <tr>
                
                <td class="required">Kubernetes API URI</td>
                <td>The URI to poll on E.g., '/api/v1/namespaces/default/pods/nginx'.</td>
                
            </tr>
            
            <tr>
                
                <td class="required">Response Field</td>
                <td>Specific field (in JSONPath expression format E.g., 'status.phase') in Kubernetes API response to check for.</td>
                
            </tr>
            
            <tr>
                
                <td class="required">Expected value</td>
                <td>Value of response field to check for.E.g., 'Running'</td>
                
            </tr>
            
            <tr>
                
                <td >Timeout (in seconds)</td>
                <td>Period to wait for response field to attain destired value before timing out.</td>
                
            </tr>
            
            <tr>
                
                <td >Output Property Location</td>
                <td>Location of the output property where the API response will be saved. If not specified, then if the procedure is invoked in a pipeline, the location will default to '/myStageRuntime/k8sWaitAPIResult' else it will default to '/myJob/k8sWaitAPIResult'.</td>
                
            </tr>
            
            </tbody>
        </table>

        

        
    </div>

    
    <div id="CreateResource">
        <h2>Create Resource (DEPRECATED)</h2>
        
        
        <p>[Deprecated] Creates or updates a resource in Kubernetes cluster based on JSON/YAML as input. Use the "Invoke Kubernetes API" procedure instead.</p>
        
        
        <h3>Create Resource Parameters</h3>
        <table class="grid">
            <thead>
            <tr>
                <th>Parameter</th>
                <th>Description</th>
            </tr>
            </thead>
            <tbody>
            
            <tr>
                
                <td class="required">Configuration</td>
                <td>Name of existing configuration which holds the authentication details for Kubernetes Cluster</td>
                
            </tr>
            
            <tr>
                
                <td class="required">URI</td>
                <td>The URI for the API for creating the resource</td>
                
            </tr>
            
            <tr>
                
                <td class="required">Request Format</td>
                <td>The request body format</td>
                
            </tr>
            
            <tr>
                
                <td >Request body</td>
                <td>The request body in JSON or YAML format.</td>
                
            </tr>
            
            <tr>
                
                <td class="required">Create or Update</td>
                <td>Whether to create or update the resource.</td>
                
            </tr>
            
            </tbody>
        </table>

        

        
    </div>

    
    <div id="ImportMicroservices">
        <h2>Import Microservices</h2>
        
        
        
    Create microservices in CloudBees Flow by importing a Kubernetes YAML file containing services and deployment configurations.
    <div>
        <ol>
            <li><b>Copy and enter the content of your Kubernetes YAML file</b></li>
            <li><b>Determine how the new microservices will be created in CloudBees Flow</b>
            <ul>
                <li><b>Create the microservices individually at the top-level within the project.</b> All microservices will be created at the top-level. Enter the following parameters:
                <ul>
                    <li>Project Name: Enter the name of the project where the microservices will be created</li>
                </ul></li>
                <li><b>Create the Microservices within an application in CloudBees Flow.</b> All microservices will be created as services within a new application. Enter the following parameters:
                <ul>
                    <li>Project Name: Enter the name of the project where the new application will be created</li>
                    <li>Create Microservices within and Application: Select the checkbox</li>
                    <li>Application Name:  The name of a new application which will be created in CloudBees Flow containing the new services.</li>
                </ul>
                </li>
            </ul></li>
            <li><b>Optionally map the services to an existing Environment Cluster</b> Select an existing Environment that contains a cluster with Kubernetes configuration details where the new microservices can be deployed. Enter the following parameters:
            <ul>
                <li>Environment Project Name: The project containing the CloudBees Flow environment where the services will be deployed.</li>
                <li>Environment Name: The name of the existing environment that contains a cluster where the newly created microservice(s) will be deployed.</li>
                <li>Cluster Name: The name of an existing EC-Kubernetes (or EC-AzureContainerService) backed cluster in the environment above where the newly created microservice(s) will be deployed.</li>
            </ul>
            </li>
        </ol>
    </div>
    
        
        
            <p>Procedure looks for services and deployments in Kubernetes
YAML file and transfers data into CloudBees Flow. Services found
in YAML file will be mapped to Services objects in CloudBees Flow,
then associated deployments will be found and containers
definitions retrieved from there.</p>
<p>If the configuration contains unsupported fields, these fields will be skipped and a warning message will be emitted to logs.
If the object with the provided name already exists in the CloudBees Flow, this object will be skipped and a warning message will be emitted to logs.</p>

        
        <h3>Import Microservices Parameters</h3>
        <table class="grid">
            <thead>
            <tr>
                <th>Parameter</th>
                <th>Description</th>
            </tr>
            </thead>
            <tbody>
            
            <tr>
                
                <td class="required">Kubernetes YAML File Content</td>
                <td>Content of a Kubernetes YAML file containing related services and deployments definitions.</td>
                
            </tr>
            
            <tr>
                
                <td class="required">Project Name</td>
                <td>The name of project in which the application or microservices will be created.</td>
                
            </tr>
            
            <tr>
                
                <td >Create Microservices within an Application</td>
                <td>(Optional) Select to create all services defined in the Kubernetes YAML file within one application in CloudBees Flow. If selected, then the application name must be provided. If unselected, microservices will be created at the top-level in the project.</td>
                
            </tr>
            
            <tr>
                
                <td >Application Name</td>
                <td>(Optional) The name of the new application that will contain the microservices. Required only if 'Create Microservices within an Application' is selected.</td>
                
            </tr>
            
            <tr>
                
                <td >Environment Project Name</td>
                <td>(Optional) The project containing the Environment where the services will be deployed.</td>
                
            </tr>
            
            <tr>
                
                <td >Environment Name</td>
                <td>(Optional) The name of an existing environment that contains a cluster where the newly created microservice(s) will be deployed.</td>
                
            </tr>
            
            <tr>
                
                <td >Cluster Name</td>
                <td>(Optional) The name of the existing CloudBees Flow cluster representing a Kubernetes cluster in the environment above where the newly created microservice(s) will be deployed.</td>
                
            </tr>
            
            </tbody>
        </table>

        

        
    </div>

    

    

    

    
    <h1 id="usecases">Use Cases</h1>

    
    <div id="RollingUpdates">
        <h2>Rolling Updates</h2>
<p>Rolling updates or rolling deployment is a way to deploy a new version with zero downtime by incrementally updating instances running an old version with the new one. In Kubernetes, this is done using rolling updates which allows a <i>Deployment's</i> update to take place by incrementally updating pods with new ones.</p>
<p>EC-Kubernetes plugin deploys services using rolling updates by default. When CloudBees Flow deploys a service to Kubernetes, the EC-Kubernetes plugin uses the following service attributes for the <i>Deployment</i>'s rolling update attributes in Kubernetes.</p>
<p>
    <ol>
        <li><b>Rolling Deployment - Min Microservice Instances: </b>Minimum number of pods that must be running during a rolling update. Defaults to 1 if not set.</li>
        <li><b>Rolling Deployment - Max Microservice Instances: </b>Maximum number of pods that can be running during a rolling update. The incremental number of pods that can be created during the rolling update is the difference between this attribute and the <b>Number of microservice instances</b>.</li>
    </ol>
</p>
<p>
    <img src="../../plugins/@PLUGIN_KEY@/images/RollingDeploymentAttributes.png" alt="screenshot" />
</p>

    </div>
    
    <div id="CanaryDeployments">
        <h2>Canary Deployments</h2>
<p>Canary deployment is a way of sending out a new release into production that plays the role of a "canary" to get an idea of how a new release will perform before rolling it out to all the users.</p>
<p>A canary deployment consists of rolling out a new release or a new functionality to a subset of users or servers. This can be achieved in a Kubernetes cluster by deploying a canary of a new release side by side with the previous release so that the new release can receive live production traffic before fully rolling it out. (Reference: <a href="https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#canary-deployments" target="_blank">Canary Deployments</a>).</p>
<p>When CloudBees Flow deploys a service to Kubernetes, the EC-Kubernetes plugin manages both the service in Kubernetes (the abstraction for a logical set of pods and a policy by which to access them) as well as the deployment controller (a deployment controller provides declarative updates for pods and replicate sets). The service created or updated by the plugin is configured to point to the pods created based on the pod specifications declared in the deployment controller.
    In order to perform a canary deployment, the following two service mapping attributes can be set:<br/>
    <ol>
        <li><b>Perform Canary Deployment: </b>If true, then a canary deployment will be performed. Any previous deployment will remain unchanged in the namespace allowing this canary deployment to receive live traffic side by side with the previous deployment.</li>
        <li><b>Number of Canary Replicas: </b>The number of replicas to create if performing a canary deployment. Defaults to 1 replica for the canary deployment.</li>
    </ol>
    <br/>Having these attributes in the service mapping allows you to use the same service deployment and undeployment processes that you would use for performing a more typical service deployment or undeployment. The following steps describe how this can be achieved.
    <ol>
        <li>Set <i>$[/myJob/canaryDeployment]</i> as the property reference value for <b>Perform Canary Deployment</b> and <i>$[/myJob/canaryReplicas]</i> for <b>Number of Canary Replicas</b>.<br/>
            <img src="../../plugins/@PLUGIN_KEY@/images/CanaryDeploymentServiceAttributes.png" alt="screenshot" /><br/><br/></li>
        <li>Now add <i>canaryDeployment</i> and <i>canaryReplicas</i> as parameters to your service or application deploy and the undeploy processes.<br/>The values specified for these parameters will automatically be resolved when the service mapping is used by EC-Kubernetes while performing the deployment. If <i>canaryDeployment</i> is set to true, then a canary deployment will be performed.<br/>
            <img src="../../plugins/@PLUGIN_KEY@/images/CanaryDeploymentDeployProcessParameters.png" alt="screenshot" /><br/>
            Similarly, during undeploy process through <i>Undeploy Service</i> procedure, if <i>canaryDeployment</i> is set to true, then the canary deployment will be removed without impacting the previous deployment or the service.
            <img src="../../plugins/@PLUGIN_KEY@/images/CanaryDeploymentUndeployProcessParameters.png" alt="screenshot" /><br/><br/>
        </li>
        <li>Finally tie the deploy and undeploy processes into an end-to-end service release pipeline including managing the canary deployments and rolling out new releases.<br/>
            <img src="../../plugins/@PLUGIN_KEY@/images/CanaryDeploymentPipeline.png" alt="screenshot" /><br/>
            <p>(1) Define a 'deploy canary' task to perform a canary deployment using the specified version on the same environment where the service is targeted.<br/>
            (2) After the canary deployment is pushed out to the environment, side by side with the previous release, use a manual task to approve the roll out of the new version if it is confirmed that the 'canary deployment is safe' and good to be rolled out.<br/>
            (3) Once the canary deployment is confirmed to be safe and the pipeline is allowed to continue, define a 'deploy new service version' task to deploy the new version of the service.<br/>
            (4) Finally, regardless of the canary deployment's result, define an 'undeploy the canary' task to undeploy the canary deployment.<br/>
            </p>
        </li>
    </ol>
</p>

    </div>
    
    <div id="BlueGreenDeployments">
        <h2>Blue/Green Deployments</h2>
<p>Blue/green deployments allow us to deploy 2 versions of an application, the current version and the next to an environment and switch seamlessly between them with zero downtime for the application.</p>
<p>A blue/green deployment can be achieved in Kubernetes by creating a new deployment, say <i>my-deployment-green</i> for running the new version while all the old pods created earlier for the older deployment, say <i>my-deployment-blue</i> are still serving all the live requests. Once the new deployment has completed successfully, and has optionally been tested through a test service, then the service in Kubernetes is switched to send requests to the newly created pods running the new version.</p>
<p>When CloudBees Flow deploys a service to Kubernetes, the EC-Kubernetes plugin manages both the service in Kubernetes (the abstraction for a logical set of pods and a policy by which to access them) as well as the deployment controller (a deployment controller provides declarative updates for pods and replicate sets). The service created or updated by the plugin is configured to point to the pods created based on the pod specifications declared in the deployment controller.
<br/>In order to orchestrate a blue/green deployment, the following two service mapping attributes can be leveraged:<br/>
<ol>
    <li><b>Service Name Override: </b>Name for the service in Kubernetes. If no override value is specified, the service name in CloudBees Flow will be used to name the service in Kubernetes.</li>
    <li><b>Deployment Name Override: </b>Name for the deployment in Kubernetes. If no value is specified, then the name of the Kubernetes service being created or updated will be used to name the deployment in Kubernetes.</li>
</ol>
<br/>Having these attributes in the service mapping allows you to use the same service deployment and undeployment processes that you would use for performing a more typical service deployment or undeployment. The following steps describe how a blue/green deployment can be orchestrated using the two service mapping attributes mentioned above.
<ol>
    <li>Set <i>$[/myJob/serviceNameOverride]</i> as the property reference value for <b>Service Name Override</b> and <i>$[/myJob/deploymentNameOverride]</i> for <b>Deployment Name Override</b>.<br/>
        <img src="../../plugins/@PLUGIN_KEY@/images/BlueGreenDeploymentServiceAttributes.png" alt="screenshot" /><br/><br/></li>
    <li>Now add <i>serviceNameOverride</i> and <i>deploymentNameOverride</i> as parameters to your service or application deploy and the undeploy processes.<br/>The values specified for these parameters will automatically be resolved when the service mapping is used by EC-Kubernetes while performing the deployment. We will use different combination of values for these two parameters to do a blue/green deployment next.<br/>
        <img src="../../plugins/@PLUGIN_KEY@/images/BlueGreenDeploymentDeployProcessParameters.png" alt="screenshot" /><br/><br/>
        Similarly, we will use different combination of values for these two parameters when undeploying the service.<br/>
        <img src="../../plugins/@PLUGIN_KEY@/images/BlueGreenDeploymentUndeployProcessParameters.png" alt="screenshot" /><br/><br/>
        <i>Note that the processes also have a parameter defined for passing in the container image version to use when deploying the service.</i><br/><br/>
    </li>
    <li>Now that the basic building blocks are in place, lets deploy the very first version of the service with no value set for <i>serviceNameOverride</i> and <i>deploymentNameOverride</i> set to say 'my-deployment-v1', where v1 is the image version number. This becomes the 'blue' deployment or the version that is currently deployed. Now, for any new version that is to be deployed for the service, the deployment pipeline should include the following tasks in order to orchestrate a blue/green deployment:<br/>
        <img src="../../plugins/@PLUGIN_KEY@/images/BlueGreenDeploymentPipeline.png" alt="screenshot" /><br/>
        <p>(1) Create an environment snapshot for the application or the microservice to capture deployment details for the service such as the current version deployed.<br/>
            (2) Now define a task for the 'green' deployment using the new version to create a deployment for. Use the service name override so that a new deployment is created in kubernetes as well as a new service end-point. The new service end-point can be used to access the 'green' deployment in order to perform any final tests or verification if required.<br/>
            (3) Now, create another task for the deploy process, this time using the deployment name override but not the service name override. This will result in the original service's selector to be updated to target the pods created through the new deployment.<br/>
            (4) Finally, define a 'cleanup blue deployment' task to undeploy the original 'blue' deployment as well as the new service end point by specifying both the service name override value and the deployment name override value.<br/>
        </p>
    </li>
</ol>
</p>

    </div>
    

    
    
    
    <h1 id="knownIssues">Known Issues</h1>
    <div>
        <p>If microservices were previously deployed on Kubernetes v1.9 using the @PLUGIN_KEY@ v1.0.5 plugin and the plugin configuration was defined to use Kubernetes API version 1.9, then after upgrading to @PLUGIN_KEY@ 1.1.0 or above, the deployment fails with &quot;HTTP/1.1 422 Unprocessable Entity&quot; error. As a work-around, the plugin configuration needs to be updated to use Kubernetes API version 1.7. After successfully redeploying all the microservices once, the plugin configuration can be switched back to Kubernetes API version 1.9.</p>

    </div>
    
    

    <h1 id="releaseNotes">Release Notes</h1>
    
    <h3>@PLUGIN_KEY@ 1.3.0</h3>
    <ul>
        
        <li>Provisioning of Binary Dependencies (for example Grape jars) in the agent resource, required by this plugin, is now delivered through a newly introduced mechanism called Plugin Dependency Management. Binary dependencies will now be seamlessly delivered to the agent resource from the Flow Server, any time a new version of a plugin is invoked the first time. Flow Repository set up is no longer required for this plugin.</li>
        
    </ul>
    
    <h3>@PLUGIN_KEY@ 1.2.3</h3>
    <ul>
        
        <li>Fixed documentation for the binary dependencies management.</li>
        
    </ul>
    
    <h3>@PLUGIN_KEY@ 1.2.2</h3>
    <ul>
        
        <li>Renaming from "Electric Cloud" to "CloudBees".</li>
        
    </ul>
    
    <h3>@PLUGIN_KEY@ 1.2.1</h3>
    <ul>
        
        <li>Fixed creating configuration by user with "@" in username.</li>
        
    </ul>
    
    <h3>@PLUGIN_KEY@ 1.2.0</h3>
    <ul>
        
        <li>Improved promotion time for the plugin.</li>
        
    </ul>
    
    <h3>@PLUGIN_KEY@ 1.1.2</h3>
    <ul>
        
        <li>Relabeled parameter label in 'Create/EditConfiguration' - 'URI for checking cluster connectivity' to 'URI Path for Checking Cluster Connectivity'</li>
        
        <li>Fixed 'Test Connection' issues within 'Create/EditConfiguration' - fixed handling of 'URI Path for Checking Cluster Connectivity'</li>
        
        <li>Extended 'Import Microservices' by possiblity to map imported microservices to Kubernetes cluster from EC-AzureContainerService</li>
        
        <li>Fixed error 'Unsupported fields in Discovery: deploymentStrategy, maxRunningPercentage, minAvailabilityPercentage'</li>
        
        <li>Default port for ElectricFlow client has been changed from insecure (8000 by default) to secure (8443 by default). If COMMANDER_SECURE property is not populated, secure port and HTTPS will be used.</li>
        
    </ul>
    
    <h3>@PLUGIN_KEY@ 1.1.1</h3>
    <ul>
        
        <li>Added report generation on unsupported tags for <i>Import Microservices</i> procedure.</li>
        
        <li>Configured the plugin to allow the ElectricFlow UI to create configs inline of procedure form.</li>
        
        <li>Added 'Test Connection' step for 'EditConfiguration' procedure.</li>
        
        <li>Updated 'Deploy Service' procedure by Warning in case of deploying 'Headless' service.</li>
        
        <li>Fixed viewing of container nodes within 'Topology View' for single-port services with unnamed port.</li>
        
    </ul>
    
    <h3>@PLUGIN_KEY@ 1.1.0</h3>
    <ul>
        
        <li>Added "Discover" procedure which can be used through the "Kubernetes Discovery" catalog item in the "Containers" service catalog for automatically creating microservice models in ElectricFlow for the services and the pods discovered within a namespace on a Kubernetes cluster.</li>
        
        <li>Added "Import Microservices" procedure which can be used through the "Import Kubernetes YAML file" catalog item in the "Containers" service catalog for creating microservice models in ElectricFlow.</li>
        
        <li>Added support for retrieving and creating the plugin configurations through the "Configurations" option on the application process step and the pipeline stage task editors.</li>
        
        <li>Verified EC-Kubernetes plugin on Kubernetes version 1.10.</li>
        
    </ul>
    
    <h3>@PLUGIN_KEY@ 1.0.6</h3>
    <ul>
        
        <li>Added 'Wait For Kubernetes API' procedure.</li>
        
    </ul>
    
    <h3>@PLUGIN_KEY@ 1.0.5</h3>
    <ul>
        
        <li>All leading and trailing whitespaces in service mapping parameters such as <i>canaryDeployment</i> will be removed before the parameter value is used.</li>
        
        <li>When performing a canary deployment, the service will not be created or updated in the Kubernetes cluster. The service must already exist in the cluster. See section <a href="#CanaryDeployments">Canary Deployments</a> for details.</li>
        
    </ul>
    
    <h3>@PLUGIN_KEY@ 1.0.4</h3>
    <ul>
        
        <li>Added a validation check in procedure <i>Deploy Service</i> to ensure that the user-specified container port names within a service are unique.</li>
        
        <li>When deploying a microservice through ElectricFlow on a Kubernetes cluster, the EC-Kubernetes plugin will now monitor the deployment progress in Kubernetes and cause the step to fail in case the deployment does not complete within the deployment timeout configured as part of the service mapping. The default timeout value is 120 seconds.</li>
        
        <li>When deploying a microservice through ElectricFlow on a Kubernetes cluster, the deployment name to use in Kubernetes can now be overridden through the service mapping. See section <a href="#BlueGreenDeployments">Blue/Green Deployments</a> for details on how this ability can be used to implement a blue/green deployment strategy.</li>
        
    </ul>
    
    <h3>@PLUGIN_KEY@ 1.0.3</h3>
    <ul>
        
        <li>Made secrets compliant with DNS-1123 standards.</li>
        
        <li>Removed unused parameter <i>additionalAttributes</i> from container mapping configuration.</li>
        
        <li>When a microservice is deployed through ElectricFlow on a Kubernetes cluster, and 'NodePort' is specified as the service type in the service mapping, then the provisioned node port is registered as a pipeline stage runtime property <i>/myStageRuntime/&lt;applicationName&gt;/&lt;serviceName&gt;/&lt;targetPort&gt;/nodePort</i>.</li>
        
        <li>When deploying a microservice through ElectricFlow on a Kubernetes cluster, the service name to use in Kubernetes can now be overridden through the service mapping.</li>
        
        <li>Deprecated procedure <i>Create Resource</i>. The newly added procedure <i>Invoke Kubernetes API</i> should be used instead for creating or updating a Kubernetes resource.</li>
        
        <li>Added support for <b>canary deployments</b>. See section <a href="#CanaryDeployments">Canary Deployments</a> for details.</li>
        
    </ul>
    
    <h3>@PLUGIN_KEY@ 1.0.2</h3>
    <ul>
        
        <li>Added support for Kubernetes API version 1.7</li>
        
        <li>Added 'kubernetesVersion' parameter in the plugin configuration to allow the user to identify the Kubernetes version running on the cluster master. The parameter will default to '1.6' if no value is specified.</li>
        
        <li>Added procedure <i>Undeploy Service</i> to undeploy a previously deployed service.</li>
        
        <li>Handled race condition in parallel creation of a namespace by multiple steps.</li>
        
    </ul>
    
    <h3>@PLUGIN_KEY@ 1.0.1</h3>
    <ul>
        
        <li>Added helper functions in base client utility to support services Discovery in EC-GoogleContainerEngine</li>
        
    </ul>
    
    <h3>@PLUGIN_KEY@ 1.0.0</h3>
    <ul>
        
        <li>First release.</li>
        
    </ul>
    
</div>
</body>
</html>
